github_doc_automation/
â”œâ”€â”€ celery_app.py              # Celery application configuration
â”œâ”€â”€ tasks.py                   # Main Celery tasks
â”œâ”€â”€ git_manager.py             # Git operations handler
â”œâ”€â”€ code_analyzer.py           # Code analysis engine
â”œâ”€â”€ llm_interface.py           # LLM API integration
â”œâ”€â”€ doc_generator.py           # Documentation generation
â”œâ”€â”€ github_client.py           # GitHub API client
â”œâ”€â”€ config.py                  # Configuration settings
â”œâ”€â”€ requirements.txt           # Python dependencies
â””â”€â”€ README.md                  # Project documentation
1. Celery Application Configuration (celery_app.py)
python
from celery import Celery
import os
from config import REDIS_URL, CELERY_CONFIG

# Create Celery application
app = Celery('github_doc_automation', broker=REDIS_URL)

# Configure Celery
app.conf.update(
    result_expires=3600,
    task_serializer='json',
    result_serializer='json',
    accept_content=['json'],
    timezone='UTC',
    enable_utc=True,
    task_acks_late=True,
    worker_prefetch_multiplier=1,
    **CELERY_CONFIG
)

# Auto-discover tasks
app.autodiscover_tasks(['tasks'])

if __name__ == '__main__':
    app.start()
2. Main Tasks Implementation (tasks.py)
python
from celery import Task
from celery_app import app
from git_manager import GitManager
from code_analyzer import CodeAnalyzer
from llm_interface import LLMInterface
from doc_generator import DocumentationGenerator
from github_client import GitHubClient
import logging
import traceback
from pathlib import Path
import tempfile
import shutil

logger = logging.getLogger(__name__)

class DocumentationTask(Task):
    """Base task class with error handling and cleanup"""

    def on_failure(self, exc, task_id, args, kwargs, einfo):
        logger.error(f"Task {task_id} failed: {exc}")
        # Cleanup workspace if exists
        workspace = kwargs.get('workspace')
        if workspace and Path(workspace).exists():
            shutil.rmtree(workspace, ignore_errors=True)

@app.task(bind=True, base=DocumentationTask)
def generate_repository_documentation(self, repo_url, branch='main', 
                                    auth_token=None, llm_provider='openai'):
    """
    Main Celery task to generate documentation for a GitHub repository

    Args:
        repo_url: GitHub repository URL
        branch: Target branch (default: main)
        auth_token: GitHub authentication token
        llm_provider: LLM service provider (openai, anthropic, etc.)

    Returns:
        dict: Results including PR URL and generated files
    """

    workspace = None
    try:
        # Create temporary workspace
        workspace = tempfile.mkdtemp(prefix='github_doc_')
        logger.info(f"Created workspace: {workspace}")

        # Initialize managers
        git_manager = GitManager(auth_token=auth_token)
        code_analyzer = CodeAnalyzer()
        llm_interface = LLMInterface(provider=llm_provider)
        doc_generator = DocumentationGenerator()
        github_client = GitHubClient(auth_token=auth_token)

        # Step 1: Clone repository
        self.update_state(state='PROGRESS', meta={'step': 'cloning', 'progress': 10})
        repo_path = git_manager.clone_repository(repo_url, workspace, branch)
        logger.info(f"Repository cloned to: {repo_path}")

        # Step 2: Analyze codebase
        self.update_state(state='PROGRESS', meta={'step': 'analyzing', 'progress': 30})
        analysis_result = code_analyzer.analyze_repository(repo_path)
        logger.info(f"Analyzed {len(analysis_result.get('files', []))} files")

        # Step 3: Generate documentation using LLM
        self.update_state(state='PROGRESS', meta={'step': 'generating', 'progress': 50})
        documentation = llm_interface.generate_documentation(analysis_result)
        logger.info("Documentation generated by LLM")

        # Step 4: Create documentation files
        self.update_state(state='PROGRESS', meta={'step': 'creating_files', 'progress': 70})
        doc_files = doc_generator.create_documentation_files(
            documentation, repo_path
        )
        logger.info(f"Created {len(doc_files)} documentation files")

        # Step 5: Create branch and commit changes
        self.update_state(state='PROGRESS', meta={'step': 'committing', 'progress': 85})
        doc_branch = f"docs/automated-documentation-{self.request.id[:8]}"
        git_manager.create_and_commit_documentation(
            repo_path, doc_files, doc_branch
        )

        # Step 6: Create pull request
        self.update_state(state='PROGRESS', meta={'step': 'creating_pr', 'progress': 95})
        pr_url = github_client.create_pull_request(
            repo_url, doc_branch, branch,
            title="Automated Documentation Improvements",
            description=generate_pr_description(doc_files, analysis_result)
        )

        # Cleanup
        shutil.rmtree(workspace, ignore_errors=True)

        return {
            'status': 'success',
            'pr_url': pr_url,
            'branch': doc_branch,
            'files_created': [str(f) for f in doc_files],
            'analysis_summary': {
                'files_analyzed': len(analysis_result.get('files', [])),
                'functions_found': len(analysis_result.get('functions', [])),
                'classes_found': len(analysis_result.get('classes', []))
            }
        }

    except Exception as exc:
        logger.error(f"Task failed: {exc}")
        logger.error(traceback.format_exc())

        # Cleanup on error
        if workspace and Path(workspace).exists():
            shutil.rmtree(workspace, ignore_errors=True)

        raise self.retry(exc=exc, countdown=60, max_retries=3)

def generate_pr_description(doc_files, analysis_result):
    """Generate a descriptive PR description"""
    description = "## Automated Documentation Improvements\n\n"
    description += "This PR contains automatically generated documentation improvements:\n\n"

    for file_path in doc_files:
        description += f"- ðŸ“ {file_path.name}\n"

    description += f"\n### Analysis Summary\n"
    description += f"- Files analyzed: {len(analysis_result.get('files', []))}\n"
    description += f"- Functions documented: {len(analysis_result.get('functions', []))}\n"
    description += f"- Classes documented: {len(analysis_result.get('classes', []))}\n"
    description += "\n*Generated by automated documentation worker*"

    return description
3. Git Manager (git_manager.py)
python
from git import Repo, GitCommandError
from pathlib import Path
import logging

logger = logging.getLogger(__name__)

class GitManager:
    """Handles all Git operations for repository management"""

    def __init__(self, auth_token=None):
        self.auth_token = auth_token

    def clone_repository(self, repo_url, workspace, branch='main'):
        """Clone repository to workspace"""
        try:
            # Add authentication to URL if token provided
            if self.auth_token and 'github.com' in repo_url:
                auth_url = repo_url.replace(
                    'https://github.com/',
                    f'https://{self.auth_token}@github.com/'
                )
            else:
                auth_url = repo_url

            repo_path = Path(workspace) / 'repo'
            repo = Repo.clone_from(auth_url, repo_path, branch=branch)
            logger.info(f"Successfully cloned {repo_url} to {repo_path}")
            return repo_path

        except GitCommandError as e:
            logger.error(f"Failed to clone repository: {e}")
            raise

    def create_and_commit_documentation(self, repo_path, doc_files, branch_name):
        """Create branch and commit documentation files"""
        try:
            repo = Repo(repo_path)

            # Create new branch
            new_branch = repo.create_head(branch_name)
            new_branch.checkout()

            # Add documentation files
            for doc_file in doc_files:
                repo.index.add([str(doc_file)])

            # Commit changes
            commit_message = f"Add automated documentation improvements\n\n" \
                           f"- Generated {len(doc_files)} documentation files\n" \
                           f"- Automated by documentation worker"

            repo.index.commit(commit_message)

            # Push branch
            origin = repo.remote('origin')
            origin.push(new_branch)

            logger.info(f"Created and pushed branch: {branch_name}")
            return branch_name

        except GitCommandError as e:
            logger.error(f"Git operation failed: {e}")
            raise
4. Code Analyzer (code_analyzer.py)
python
import ast
import os
from pathlib import Path
from typing import Dict, List, Any
import logging

logger = logging.getLogger(__name__)

class CodeAnalyzer:
    """Analyzes source code to extract structure and documentation needs"""

    SUPPORTED_EXTENSIONS = {'.py', '.js', '.ts', '.java', '.cpp', '.c', '.cs'}

    def analyze_repository(self, repo_path: Path) -> Dict[str, Any]:
        """Analyze entire repository structure"""
        analysis = {
            'files': [],
            'functions': [],
            'classes': [],
            'modules': [],
            'structure': {}
        }

        for file_path in self._find_source_files(repo_path):
            try:
                file_analysis = self._analyze_file(file_path)
                if file_analysis:
                    analysis['files'].append(file_analysis)
                    analysis['functions'].extend(file_analysis.get('functions', []))
                    analysis['classes'].extend(file_analysis.get('classes', []))

            except Exception as e:
                logger.warning(f"Could not analyze {file_path}: {e}")
                continue

        analysis['structure'] = self._build_project_structure(repo_path)
        return analysis

    def _find_source_files(self, repo_path: Path) -> List[Path]:
        """Find all source code files in repository"""
        source_files = []

        for file_path in repo_path.rglob('*'):
            if (file_path.is_file() and 
                file_path.suffix in self.SUPPORTED_EXTENSIONS and
                not self._should_ignore_file(file_path)):
                source_files.append(file_path)

        return source_files

    def _analyze_file(self, file_path: Path) -> Dict[str, Any]:
        """Analyze individual source file"""
        if file_path.suffix == '.py':
            return self._analyze_python_file(file_path)
        else:
            # Basic analysis for other file types
            return self._analyze_generic_file(file_path)

    def _analyze_python_file(self, file_path: Path) -> Dict[str, Any]:
        """Detailed Python file analysis using AST"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                source = f.read()

            tree = ast.parse(source)

            analysis = {
                'path': str(file_path),
                'type': 'python',
                'functions': [],
                'classes': [],
                'imports': [],
                'docstring': ast.get_docstring(tree)
            }

            for node in ast.walk(tree):
                if isinstance(node, ast.FunctionDef):
                    analysis['functions'].append(self._extract_function_info(node))
                elif isinstance(node, ast.ClassDef):
                    analysis['classes'].append(self._extract_class_info(node))
                elif isinstance(node, (ast.Import, ast.ImportFrom)):
                    analysis['imports'].append(self._extract_import_info(node))

            return analysis

        except Exception as e:
            logger.error(f"Failed to analyze Python file {file_path}: {e}")
            return None

    def _extract_function_info(self, node: ast.FunctionDef) -> Dict[str, Any]:
        """Extract function information from AST node"""
        return {
            'name': node.name,
            'args': [arg.arg for arg in node.args.args],
            'line_number': node.lineno,
            'docstring': ast.get_docstring(node),
            'is_async': isinstance(node, ast.AsyncFunctionDef),
            'decorators': [ast.unparse(dec) for dec in node.decorator_list] if hasattr(ast, 'unparse') else []
        }

    def _extract_class_info(self, node: ast.ClassDef) -> Dict[str, Any]:
        """Extract class information from AST node"""
        methods = []
        for item in node.body:
            if isinstance(item, ast.FunctionDef):
                methods.append(self._extract_function_info(item))

        return {
            'name': node.name,
            'line_number': node.lineno,
            'docstring': ast.get_docstring(node),
            'methods': methods,
            'bases': [ast.unparse(base) for base in node.bases] if hasattr(ast, 'unparse') else []
        }

    def _should_ignore_file(self, file_path: Path) -> bool:
        """Check if file should be ignored"""
        ignore_patterns = {
            'node_modules', '.git', '__pycache__', '.pytest_cache',
            'venv', 'env', '.venv', 'dist', 'build', '.tox'
        }

        return any(pattern in str(file_path) for pattern in ignore_patterns)

    def _build_project_structure(self, repo_path: Path) -> Dict[str, Any]:
        """Build high-level project structure"""
        structure = {
            'name': repo_path.name,
            'directories': [],
            'main_files': []
        }

        # Find main directories and important files
        for item in repo_path.iterdir():
            if item.is_dir() and not item.name.startswith('.'):
                structure['directories'].append(item.name)
            elif item.is_file() and item.name in ['README.md', 'setup.py', 'requirements.txt', 'package.json']:
                structure['main_files'].append(item.name)

        return structure
5. LLM Interface (llm_interface.py)
python
import openai
import anthropic
import json
import logging
from typing import Dict, Any, List
from tenacity import retry, stop_after_attempt, wait_exponential

logger = logging.getLogger(__name__)

class LLMInterface:
    """Interface for various LLM providers"""

    def __init__(self, provider='openai', api_key=None):
        self.provider = provider
        self.api_key = api_key
        self._setup_client()

    def _setup_client(self):
        """Initialize LLM client based on provider"""
        if self.provider == 'openai':
            openai.api_key = self.api_key
        elif self.provider == 'anthropic':
            self.client = anthropic.Anthropic(api_key=self.api_key)

    @retry(stop=stop_after_attempt(3), wait=wait_exponential(multiplier=1, min=4, max=10))
    def generate_documentation(self, analysis_result: Dict[str, Any]) -> Dict[str, Any]:
        """Generate documentation using LLM"""

        # Prepare prompt for LLM
        prompt = self._build_documentation_prompt(analysis_result)

        if self.provider == 'openai':
            return self._generate_with_openai(prompt)
        elif self.provider == 'anthropic':
            return self._generate_with_anthropic(prompt)
        else:
            raise ValueError(f"Unsupported LLM provider: {self.provider}")

    def _build_documentation_prompt(self, analysis: Dict[str, Any]) -> str:
        """Build comprehensive prompt for documentation generation"""

        prompt = '''
You are a technical documentation expert. Based on the following code analysis, generate comprehensive documentation.

## Code Analysis Summary:
'''

        # Add project structure
        if 'structure' in analysis:
            prompt += f"\n### Project Structure:\n"
            prompt += f"Project: {analysis['structure'].get('name', 'Unknown')}\n"
            prompt += f"Directories: {', '.join(analysis['structure'].get('directories', []))}\n"
            prompt += f"Main files: {', '.join(analysis['structure'].get('main_files', []))}\n"

        # Add function information
        if analysis.get('functions'):
            prompt += "\n### Functions Found:\n"
            for func in analysis['functions'][:10]:  # Limit to first 10 functions
                prompt += f"- {func['name']}({', '.join(func.get('args', []))})\n"
                if func.get('docstring'):
                    prompt += f"  Current doc: {func['docstring'][:100]}...\n"

        # Add class information
        if analysis.get('classes'):
            prompt += "\n### Classes Found:\n"
            for cls in analysis['classes'][:5]:  # Limit to first 5 classes
                prompt += f"- {cls['name']} (methods: {len(cls.get('methods', []))})\n"
                if cls.get('docstring'):
                    prompt += f"  Current doc: {cls['docstring'][:100]}...\n"

        prompt += '''

## Please generate:

1. **README.md**: A comprehensive README with:
   - Project description and purpose
   - Installation instructions
   - Usage examples
   - API documentation (if applicable)
   - Contributing guidelines

2. **API_DOCUMENTATION.md**: Detailed API documentation including:
   - Function/method signatures
   - Parameter descriptions
   - Return value documentation
   - Usage examples
   - Error handling

3. **ARCHITECTURE.md**: High-level architecture overview:
   - System components
   - Data flow
   - Key design decisions

Return the response as a JSON object with keys: "readme", "api_docs", "architecture", each containing the markdown content.
'''

        return prompt

    def _generate_with_openai(self, prompt: str) -> Dict[str, Any]:
        """Generate documentation using OpenAI"""
        try:
            response = openai.ChatCompletion.create(
                model="gpt-4",
                messages=[
                    {"role": "system", "content": "You are a technical documentation expert."},
                    {"role": "user", "content": prompt}
                ],
                max_tokens=4000,
                temperature=0.3
            )

            content = response.choices.message.content

            # Try to parse as JSON, fallback to structured text
            try:
                return json.loads(content)
            except json.JSONDecodeError:
                # Fallback: structure the content manually
                return self._structure_text_response(content)

        except Exception as e:
            logger.error(f"OpenAI API error: {e}")
            raise

    def _generate_with_anthropic(self, prompt: str) -> Dict[str, Any]:
        """Generate documentation using Anthropic Claude"""
        try:
            response = self.client.messages.create(
                model="claude-3-sonnet-20240229",
                max_tokens=4000,
                temperature=0.3,
                messages=[
                    {"role": "user", "content": prompt}
                ]
            )

            content = response.content.text

            # Try to parse as JSON
            try:
                return json.loads(content)
            except json.JSONDecodeError:
                return self._structure_text_response(content)

        except Exception as e:
            logger.error(f"Anthropic API error: {e}")
            raise

    def _structure_text_response(self, content: str) -> Dict[str, Any]:
        """Structure plain text response into sections"""
        sections = {
            'readme': '',
            'api_docs': '',
            'architecture': ''
        }

        # Simple heuristic to split content
        parts = content.split('##')
        for part in parts:
            if 'README' in part.upper():
                sections['readme'] = part.strip()
            elif 'API' in part.upper() or 'DOCUMENTATION' in part.upper():
                sections['api_docs'] = part.strip()
            elif 'ARCHITECTURE' in part.upper():
                sections['architecture'] = part.strip()

        # If no clear sections, put everything in README
        if not any(sections.values()):
            sections['readme'] = content

        return sections
6. Documentation Generator (doc_generator.py)
python
from pathlib import Path
from typing import Dict, List, Any
import logging

logger = logging.getLogger(__name__)

class DocumentationGenerator:
    """Generates documentation files from LLM output"""

    def create_documentation_files(self, documentation: Dict[str, Any], 
                                 repo_path: Path) -> List[Path]:
        """Create documentation files in the repository"""

        created_files = []

        # Create README.md if it doesn't exist or create README_AI.md
        readme_content = documentation.get('readme', '')
        if readme_content:
            readme_file = self._create_readme(repo_path, readme_content)
            if readme_file:
                created_files.append(readme_file)

        # Create API documentation
        api_docs = documentation.get('api_docs', '')
        if api_docs:
            api_file = repo_path / 'docs' / 'API_DOCUMENTATION.md'
            api_file.parent.mkdir(exist_ok=True)
            api_file.write_text(api_docs, encoding='utf-8')
            created_files.append(api_file)
            logger.info(f"Created API documentation: {api_file}")

        # Create architecture documentation
        arch_docs = documentation.get('architecture', '')
        if arch_docs:
            arch_file = repo_path / 'docs' / 'ARCHITECTURE.md'
            arch_file.parent.mkdir(exist_ok=True)
            arch_file.write_text(arch_docs, encoding='utf-8')
            created_files.append(arch_file)
            logger.info(f"Created architecture documentation: {arch_file}")

        # Create additional documentation files
        if 'contributing' in documentation:
            contrib_file = repo_path / 'CONTRIBUTING.md'
            contrib_file.write_text(documentation['contributing'], encoding='utf-8')
            created_files.append(contrib_file)

        return created_files

    def _create_readme(self, repo_path: Path, content: str) -> Path:
        """Create README file, avoiding overwriting existing ones"""
        readme_path = repo_path / 'README.md'

        # If README.md exists, create README_AI.md instead
        if readme_path.exists():
            readme_path = repo_path / 'README_AI.md'
            logger.info("README.md exists, creating README_AI.md instead")

        readme_path.write_text(content, encoding='utf-8')
        logger.info(f"Created README: {readme_path}")
        return readme_path
7. GitHub Client (github_client.py)
python
import requests
import json
import logging
from typing import Optional
from urllib.parse import urlparse

logger = logging.getLogger(__name__)

class GitHubClient:
    """GitHub API client for creating pull requests"""

    def __init__(self, auth_token: str):
        self.auth_token = auth_token
        self.headers = {
            'Authorization': f'token {auth_token}',
            'Accept': 'application/vnd.github.v3+json',
            'Content-Type': 'application/json'
        }
        self.base_url = 'https://api.github.com'

    def create_pull_request(self, repo_url: str, head_branch: str, 
                          base_branch: str, title: str, description: str) -> str:
        """Create a pull request"""

        # Extract owner and repo from URL
        owner, repo = self._parse_repo_url(repo_url)

        # Create PR payload
        payload = {
            'title': title,
            'body': description,
            'head': head_branch,
            'base': base_branch,
            'maintainer_can_modify': True
        }

        # Create pull request
        url = f'{self.base_url}/repos/{owner}/{repo}/pulls'

        try:
            response = requests.post(url, headers=self.headers, 
                                   data=json.dumps(payload))
            response.raise_for_status()

            pr_data = response.json()
            pr_url = pr_data['html_url']

            logger.info(f"Created pull request: {pr_url}")

            # Add labels to the PR
            self._add_labels_to_pr(owner, repo, pr_data['number'])

            return pr_url

        except requests.exceptions.RequestException as e:
            logger.error(f"Failed to create pull request: {e}")
            raise

    def _parse_repo_url(self, repo_url: str) -> tuple:
        """Parse GitHub repository URL to extract owner and repo name"""
        parsed = urlparse(repo_url)
        path_parts = parsed.path.strip('/').split('/')

        if len(path_parts) >= 2:
            owner, repo = path_parts, path_parts
            # Remove .git suffix if present
            if repo.endswith('.git'):
                repo = repo[:-4]
            return owner, repo
        else:
            raise ValueError(f"Invalid GitHub URL: {repo_url}")

    def _add_labels_to_pr(self, owner: str, repo: str, pr_number: int):
        """Add labels to the pull request"""
        labels = ['documentation', 'automated', 'enhancement']

        url = f'{self.base_url}/repos/{owner}/{repo}/issues/{pr_number}/labels'
        payload = {'labels': labels}

        try:
            response = requests.post(url, headers=self.headers,
                                   data=json.dumps(payload))
            if response.status_code == 200:
                logger.info(f"Added labels to PR #{pr_number}")
        except Exception as e:
            logger.warning(f"Could not add labels to PR: {e}")
8. Configuration (config.py)
python
import os
from pathlib import Path

# Redis/Celery Configuration
REDIS_URL = os.getenv('REDIS_URL', 'redis://localhost:6379/0')
RABBITMQ_URL = os.getenv('RABBITMQ_URL', 'amqp://localhost')

# Use Redis by default, fallback to RabbitMQ
BROKER_URL = REDIS_URL if REDIS_URL else RABBITMQ_URL

# Celery Configuration
CELERY_CONFIG = {
    'broker_url': BROKER_URL,
    'result_backend': REDIS_URL,
    'task_serializer': 'json',
    'result_serializer': 'json',
    'accept_content': ['json'],
    'timezone': 'UTC',
    'enable_utc': True,
    'task_acks_late': True,
    'worker_prefetch_multiplier': 1,
    'task_routes': {
        'tasks.generate_repository_documentation': {'queue': 'documentation'},
    },
    'beat_schedule': {
        # Example: Schedule periodic documentation updates
        'update-docs-weekly': {
            'task': 'tasks.generate_repository_documentation',
            'schedule': 604800.0,  # Weekly
            'args': ('https://github.com/example/repo.git',)
        },
    }
}

# API Keys (set via environment variables)
GITHUB_TOKEN = os.getenv('GITHUB_TOKEN')
OPENAI_API_KEY = os.getenv('OPENAI_API_KEY')
ANTHROPIC_API_KEY = os.getenv('ANTHROPIC_API_KEY')

# Logging Configuration
LOGGING_CONFIG = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'verbose': {
            'format': '{levelname} {asctime} {module} {message}',
            'style': '{',
        },
    },
    'handlers': {
        'file': {
            'level': 'INFO',
            'class': 'logging.FileHandler',
            'filename': 'documentation_worker.log',
            'formatter': 'verbose',
        },
        'console': {
            'level': 'INFO',
            'class': 'logging.StreamHandler',
            'formatter': 'verbose',
        },
    },
    'loggers': {
        '': {
            'handlers': ['file', 'console'],
            'level': 'INFO',
            'propagate': False,
        },
    },
}
9. Requirements.txt
text
celery[redis]==5.3.4
redis==5.0.1
gitpython==3.1.40
openai==1.3.8
anthropic==0.7.8
requests==2.31.0
pathlib2==2.3.7
tenacity==8.2.3
python-dotenv==1.0.0
10. Usage Example
python
# Start Celery worker
# celery -A celery_app worker --loglevel=info --queues=documentation

# Submit a documentation task
from tasks import generate_repository_documentation

# Asynchronous execution
result = generate_repository_documentation.delay(
    repo_url='https://github.com/example/my-project.git',
    branch='main',
    auth_token='your_github_token',
    llm_provider='openai'
)

# Check task status
print(f"Task ID: {result.task_id}")
print(f"Status: {result.status}")

# Get results (blocks until complete)
final_result = result.get(timeout=600)  # 10 minute timeout
print(f"PR Created: {final_result['pr_url']}")
Security Considerations
Authentication: Store GitHub tokens and API keys securely using environment variables

Sandboxing: Each task runs in isolated temporary directories

Rate Limiting: Implement proper rate limiting for both GitHub and LLM APIs

Input Validation: Validate repository URLs and parameters

Error Handling: Comprehensive error handling with proper logging

Resource Cleanup: Ensure temporary directories are always cleaned up

Deployment
Docker: Create containerized workers for easy deployment

Queue Management: Use separate queues for different priorities

Monitoring: Implement health checks and task monitoring

Scaling: Deploy multiple workers across different machines

Persistence: Use persistent message brokers and result backends

This implementation provides a robust, scalable system for automating documentation generation while ensuring code safety and following best practices.